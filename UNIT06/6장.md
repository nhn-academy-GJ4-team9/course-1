# Loop Statements

## Summary

- Repetition of statements
- The while statement
- Input loop
- Loop schemes
- The for statement
- The do statement
- Nested loops
- Flow control statements

## Repetition of statements

문제를 해결하기위해 종종 특정 statement를 반복해서 variable의 변수를 바꿀 필요가 있습니다.
자바에서는 두가지의 반복문을 제공합니다.

- 복합적인 구문으로 이뤄진 Loop statements(or Iterative statements)의 사용
- _recursive methods_ 의 사용
  이 파트에서는 loop문들의 사용법에 대해 알고 추후 *recursion*에 대해 알아볼 것입니다.

## Definite and indefinite loops

loop문에는 반복문의 body에 존재하는 반복횟수에 따른 두가지 개념이 존재합니다.

- definite loops는 반복 회수가 반복문의 실행 전에 알게되는 형태입니다.
- indefinite loops는 박복 횟수가 반복문 안의 특정 조건이 만족 할때까지 반복 횟수를 알 수 없는 형태입니다.

자바에서는 두가지 타입 모두가 구현 _while_ statement를 통해 구현 가능합니다.

## The while loop

while 문

```
while(condition)
    statement
```

- condition boolean 타입의 expression이다.
- statement는 단일 statement 혹은 반복문의 body라고 불린다.

condition의 값이 판별되고 만약 true라면 statement는 실행되고 condition의 판별이 false가 될때까지 반복된다.

## Characteristic elements in the design of a loop

    initialization
    while(condition){
        operation
        next step
    }

- initialization: 반복문에 사용될 변수를 반복문의 실행전에 설정합니다.
- condition : 매 반복마다 해당 value를 판단하고 참인지 거짓인지에 따라 반복의 실행과 종료를 결정합니다.
- operation of the loop : 각 반복마다 계산되어 실행되는 부분입니다.
- next step : 변수의 증감을 컨트롤해 반복을 제어합니다.

반복문을 설계할때는 제때 종료되는 가를 확인하는게 중요합니다. 특히나 반복문의 value condition이 잘못된 결과를 도출하는지 확인해야합니다.

## Common erros in writing while loops
- condition을 결정할 변수 초기화를 잊어버리는 것.
````
EXAMPLE:
  int i;
  String s;
  while (s != null) {
    i = Integer.parseInt(s);
    System.out.println(i*i);
    s = JOptionPane.showInputDialog("Input an Integer");
   }
````
- condition 변수의 업데이트를 잊어버리는 것. 이 경우 반복이 종료되지 않습니다.
~~~~
EXAMPLE:
  int i;
  String s;
  s = JOptionPane.showInputDialog("Input an integer");
  while (s != null) {
    i = Integer.parseInt(s);
    System.out.println(i*i);
  }
~~~~

- 반복 횟수를 1회 빼먹는 것. 일반적으로 반복의 condition과 condition에 사용된 value initialization의 불일치로 발생합니다.
~~~
EXAMPLE: Print out 10 stars.
  int i = 0;
  while(i <= 10) {    //should be (i < 10)
    System.out.print("*");
    i++;
  }
~~~~
이런 전형적인 에러를 피하기 위해 반복을 작은 값부터 시작하는 것이 좋습니다.

## Loop schemes
다음과 같은 반복문이 필요한 일반적인 기초 연산들이 있습니다.
- 횟수 세기 
- 축적
- 집합 내 특정 값들
~~~
EXAMPLE: 입력된 String 횟수 세기
  String s;
  int counter;
  
  count = 0;
  s = JOptionPane.showInputDialog("Input a string");
  while(s != null) {
    counter++;
    s = JOptionPane.showInputDialog("Input a string");
  }
  
  System.out.println("Number of strings in input = " + counter);
~~~
~~~
EXAMPLE: 입력된 정수값들의 합(= 축적)
  String s;
  int n;
  int sum;
  
  sum = 0; 
  s = JOptionPane.showInputDialog("Input an integer");
  while (s != null) {
    n = Integer.parseInt(s);
    sum = sum + n;
    s = JOptionPane.InputDialog("Input an integer");
  }

  System.out.println("sum = " + sum);
~~~
~~~
EXAMPLE: 입력된 정수 값 집합들에서 최댓값(= 특정값)을 찾는 경의 예시
  모든 정수가 0이상임을 알고 있다고 가정합니다.
  
  String s;
  int n;
  int max;
   
  max  = -1;
  s = JOptionPane.showInputDialog("Input an integer");
  while (s != null) {
    n = Integer.parseInt(s);
    if ( n > max) max = n;
    s = JOptionPane.showInputDialog("Input an intger");
  }
    
  if (max == -1)
    System.out.println("empty set of values");
   else
    System.out.println("maximum = " + max);
~~~
## The *for* loop
*Syntax*:

    for (initialization; condition; update)
    statement
while 반복문으로 바꾸어보면 다음과 같다.
~~~
  initialization;
  while (condition) {
    statement;
    update;
    }
~~~
initialization에서 제어 변수가 선언되고 그 변수의 scope는 for 반복문에 제한되어 있다.
while문의 형태에서 확인 해보면 블락안에 전부 감싸져있음을 알 수 있다.

~~~
EXAMPLE:
  for (int i = 0; i < 10; i++) {
    System.out.println(i * i);
  }
  System.out.println("value of i = " + i); // ERROR! i is not visible
~~~
for의 세 요소는 ';'만을 삽입하으로써 생략이 가능하다. condition이 생략된다면 이는 항상 true 이다.
하지만 권장하는 바로는 세 요소를 위의 의미에 맞게 사용하여 control variable에 참조하게 하고 반복문의 body에서는 조정하려 하지 마라.

일반적으로 *initialaization*과 *update*는 side-effect가 있는 expression이 될 수 있다.
이를 통해 여러 variable을 initialize나 update 할 수 있지만 권장 하지 않는다.

## The *do* loop
while 반복문은 반복의 끝을 제어하는 condition이 반복문의 처음에서 확인 된다.
*do* 반복문은 *while*가 비슷하지만 condition이 반복문의 끝에서 확인 된다.

~~~
Syntax:
  do
    statement
  while (condition);
~~~
statement가 실행되고나서 condition이 확인된다. 그리고 true라면 false가 될 때까지 statement가 다시 실행된다.
이 시점에서 즉시 다음 반복이 실행된다.
~~~
EXAMPLE: Print out 100 stars.
  int i = 0;
  do {
    System.out("*");
    i++;
  } while (i < 100);
  ~~~
반복문의 condition이 마지막에 확인되기에 반복문의 body는 반드시 한번은 실행되야 하는 경우 사용한다.
일반적으로 condition variable을 initialize를 body안에서 하는것으로 충분한 점이 *while*과 다른 점이다.
## Nested loops
반복문의 body 자체에도 반복문을 가질 수 있다 이를 *nested loop* 라고 한다. 

~~~
EXAMPLE: Print out the multiplication table
  public class MultiplicationTable {
    static final int NMAX = 10;
    public static void main(String[] args) {
      int row, column;
      
      for (row = 1; row <= NMAX; row++) {
        for (column = 1; column <= NMAX; column++)
          System.out.print(row * column + " ");
        System.out.println();
        }
      }
    }
~~~
NMAX라는 행렬의 갯수를 나타내는 global 상수를 만들었고 이 결과를 확인하면
~~~
1 2 3 4 5 6 7 8 9 10
2 4 6 8 10 12 14 16 18 20
3 6 ...................30
.                       .
.                       .
.                       .
.                       .
.                       .
10 20 30 ..............100
~~~

## Flow control statmements
제어문은 다음 statement의 실행을 결정한다. *if-else,if,switch,while,for,do*가 제어문이다.
하지만 이 statements들은 우리가 다음 실행을 임으로 결정 할 수 있게 하지않는다.
대신에 프로그램의 구조의 실행흐름을 결정한다.
다른 언어와 마찬가지로 java또한 일정 수준의 *jump statements*를 제공한다. 
이 statements는 실행흐름을 막고 다른 statements로 "jumping" 하게 해준다.
#### jump statements
- break (현재 loop나 switch의 흐름을 jump 하게한다.)
- continue (루프의 condition으로 jump 한다.)

#### 주의 사항
- jump statements들은 일반적으로 특정 상황말고는 사용하지 않는걸 권한다.
- *return* statements 또한 현재 메소드의 활성을 프로그래머가 제어 할 수 있다.

unit5의 switch statement에서 본것과 같이 *break*는 제어문을 빠져나가게 해준다.
~~~
EXAMPLE: 10개의 실수를 입력받아 제곱근을 계산하고 음수를 입력받으면 즉시 반복을 멈추게 한다.
  double a;
  for (int i = 0; i < 10; i++) {
    a = Double.parseDouble(
            JOptionPane.showInputDialog("Input a nonnegative real"));
    if (a >= 0)
      System.out.println(Math.sqrt(a));
    else {
      System.out.println("Error);
      break;
    }
  }
~~~
nested loop나 switch statements의 loop에서 *break*의 실행은 한 단계의 body만을 빠져나가게 한다.

### Elimination of *break*
*break* statement로 실행을 조정하고 더 나아가 반복문에 사용된다면
- 프로그램의 구조를 잃게되고 동일한 행동을 구현하기 위한 효율성을 얻을 수 있습니다.

일반적으로 *break* statement는 언제든 제거가 가능합니다.
하지만 이 결정은 효율성과 가독성 중 우위를 평가해서 작성해야합니다.

### The *continue* statement
*continue* statement는 오직 반복문에서만 사용 할 수 있습니다.

이 효과는 현재의 반복을 생략하고 즉시 다음 반복으로 jump 합니다.

- *continue statement*가 실행되도 그 뒤의 *update*는 반드시 실행됨을 잊지 말아야합니다.

continue는 반복으로 특정 계산만을 하고 싶지만 계속해서 반복을 진행해야 할 경우 사용됩니다.







  
