# 8. Files and input/output streams

## Summary

- The concept of file
- Writing and reading text files
- Operations on files
- Input streams: keyboard, file, internet
- Output streams: file, video
- Generalized writing and reading through streams

## **The concept of file**

**파일은** 대용량 저장 장치에 데이터를 영구적으로 저장하는 가장 중요한 메커니즘이다.  

파일에는 다음과 같이 포함된다.

- 프로그램에서는 해석할 수 있지만 사람은 쉽게 해석할 수 없는 형식의 데이터( 바이너리 파일 )
- 표준 방식(예: ASCII 또는 유니코드 사용)으로 코드화되고 사용자가 직접 읽을 수 있는 영숫자 문자( 텍스트 파일 ). 텍스트 파일은 일반적으로 일련의 문자를 포함하고 특수 문자로 끝나는 일련의 줄로 구성된다.

파일에 대한 가장 중요한 작업은 생성 , 읽기 , 쓰기 , 이름 바꾸기 , 삭제 이다 . 

## **Operations on files**

파일에 대한 읽기 및 쓰기 작업을 실행하려면 작업을 수행하기 전에 파일을 *열고* 작업이 끝난 후에 파일을 *닫아야* 한다.

- **파일을 여는 것은** Java 프로그램 내에서 파일을 조작하고 싶다는 것을 운영 체제에 알리는 것을 의미하며, 운영 체제는 그러한 작업이 가능하고 허용되는지 여부를 확인한다. 파일을 여는 방법에는 읽기용으로 열기 와 쓰기용으로 열기 라는 두 가지 방법이 있다 . 이에 따라 운영 체제의 동작이 달라진다다. 예를 들어, 두 개의 응용 프로그램에서 두 개의 파일을 읽기용으로 동시에 열 수 있지만 쓰기용으로는 열 수 없다. 또는 CD에 있는 파일을 읽기 위해 열 수 있지만 쓰기 위해 열 수는 없다. 많은 프로그래밍 언어(Java 포함)에서 쓰기 위해 파일을 여는 것은 실제로 새 파일을 만드는 것을 의미한다.
- **파일을 닫는다는** 것은 이전에 열었던 파일이 프로그램에서 더 이상 사용되지 않음을 운영 체제에 나타내는 것을 의미한다. 파일을 닫으면 파일에 기록된 데이터가 하드 디스크로 효과적으로 전송되도록 하는 효과도 있다.

## **Exceptions**

파일 작업은 일반적으로 프로그램이 처리할 수 없는 예상치 못한 상황을 일으킬 수 있다(예: 읽기 위해 파일을 열려고 하고 존재하지 않는 파일 이름을 지정하는 경우). 이러한 상황을 **예외** 라고 한다 .예외 상황인 경우  적절한 Java 코드를 삽입하여 프로그램에서 처리해야 한다(단원 9 참조).

## **Writing text files**

파일에 텍스트 문자열을 쓰려면 다음을 수행해야 한다.

1. 파일 이름과 연관된 FileWriter 클래스의 객체를 생성 하고 방금 생성된 FileWriter 객체와 연관된 PrintWriter 클래스의 객체를 생성하여 쓰기 위해 파일을 연다
2. PrintWriter 객체 의 print 및 println 메서드를 사용하여 파일에 텍스트를 쓴다 .
3. 쓰기가 끝나면 파일을 닫는다.

```jsx
// 1. 쓰기용 파일 열기(파일 생성)
FileWriter f = new FileWriter("test.txt");
PrintWriter out = new PrintWriter(f);

// 2. 파일에 텍스트 쓰기
out.println("some text to write to the file");

// 3. 출력 채정과 파일 닫기
out.close();
f.close();
```

참고

- FileWriter클래스의 생성자를 호출하면  파일을 만든다. 파일이 이미 존재하는 경우 먼저 모든 내용이 지워진다
- 파일의 이전 내용을 지우지 않고 이미 존재하는 파일에 텍스트를 추가하려면 FileWriter(String, boolean) 시그니처가 있는 생성자를 사용해야 하며 두 번째 인수에 true 값을 지정해야 한다.

## **Program for writing to a file**

다음 프로그램은 test.txt 라는 텍스트 파일을 생성하고 그 파일에 "some text write on a file"이라는 문자열을 쓴다.

```
import java.io.*;

public class WritingOnFile {
  public static void main(String[] args) throws IOException {
    // opening the file for writing
    FileWriter f = new FileWriter("test.txt");
    // creation of the object for writing
    PrintWriter out = new PrintWriter(f);

    // writing text on the file
    out.println("some text written on a file");

    // closing the output channel and the file
    out.close();
    f.close();
  }
}
```

프로그램은 다음을 선언하여 파일에 액세스할 때 발생할 수 있는 오류를 처리해야 한다.

• public static void main(String[] args) throws IOException

## **Loop schema for writing to a file**

파일에 데이터를 쓸 때 일반적으로 다음과 같은 구조의 루프를 사용한다.

```jsx
PrintWriter out = ...
while (condition) {
   out.println(data);
   ...
}
out.close();
```

## **Reading from a text file**

파일에서 텍스트 문자열을 읽으려면 다음을 수행해야 한다.

1. FileReader 클래스의 객체를 생성 하고 방금 생성한 FileReader 객체와 연관된 BufferedReader 클래스의 객체를 생성 하여 읽을 파일을 연다 .
2. BufferedReader 객체 의 readLine 메서드를 사용하여 파일에서 텍스트 줄을 읽는다 .
3. 파일 읽기가 끝나면 파일을 닫는다 .

위에서 설명한 세 가지 단계를 구현하는 Java 문은 다음과 같습니다.

```
// 1. 읽을 파일 열기
FileReader f = new FileReader("test.txt");;
BufferedReader in = new BufferedReader(f);

// 2. 파일에서 텍스트 한 줄 읽기
String line = in.readLine();

// 3. 파일 닫기
f.close();
```

노트:

- 읽기 위해 열려는 파일이 존재하지 않으면 FileReader 객체가 생성될 때 FileNotFoundException 유형의 예외가 발생한다.
- 파일을 연 후 첫 번째 줄부터 읽기 시작한다. 그런 다음 readLine 메서드를 호출할 때마다 입력을 다음 줄로 진행하여 readLine 을 호출할 때마다 파일에서 다음 텍스트 줄을 읽게 된다.

## **Program for reading from a file**

다음 프로그램은 test.txt 라는 텍스트 파일을 열고 , 그 파일에서 한 줄의 텍스트를 읽고, 인쇄한다.

```
public class ReadingFromFile {
  public static void main(String[] args) throws IOException {
    // opening the file for reading
    FileReader f = new FileReader("test.txt");
    // creation of the object for reading
    BufferedReader in = new BufferedReader(f);

    // reading a line of text from the file
    String line = in.readLine();
    System.out.println(line);

    // closing the file
    f.close();
  }
```

참고 : 프로그램에서 첫 번째 줄부터 시작하여 파일의 내용을 다시 읽어야 하는 경우 파일을 닫았다가 읽기 위해 다시 열어야 한다(예: 다음 단락 참조).

## **Loop schema for reading from a file**

파일에서 일련의 문자열을 읽을 때 일반적으로 다음과 같은 구조의 루프를 사용해야 한다.

```jsx
BufferedReader in = ...
String line = in.readLine();
while (line != null) {
   process line
   line = in.readLine();
}
```

## **Renaming and deleting a file in Java**

**파일을 삭제** 하려면 (즉, 대용량 저장 장치에서 완전히 제거하려면) 삭제할 파일 이름으로 생성된 File 유형 의 객체에 대해 delete 메소드를 호출한다.

```jsx
File f1 = new File("garbage.txt");
boolean b = f1.delete();
// if b is true, then the file has been deleted successfully
```

**file 의 이름을 바꾸** 려면 이름을 바꿀 파일과 파일에 부여할 새 이름을 각각 나타내는 File 유형의 두 개체에 renameTo 메서드를 호출한다.

```jsx
File f1 = new File("oldname.txt");
File f2 = new File("newname.txt");
boolean b = f1.renameTo(f2);
// if b is true, then the file has been renamed successfully
```

## **Input/output streams**

![Untitled](8%20Files%20and%20input%20output%20streams%20528e5885c2a147819d476dca74a2e624/Untitled.png)

예시 input streams:

- keyboard : InputStream is = [System.in](http://system.in/);
- file : FileInputStream is = new FileInputStream("data.txt");
- Internet resource =
    
    URL u = new URL("[http://www.inf.unibz.it/](http://www.inf.unibz.it/)");
    InputStream is = u.openStream();
    

예시 output streams:

- video : OutputStream os = System.out;
- file : FileOutputStream os = new FileOutputStream("data.txt");

## **Reading from an input stream and writing to an output stream**

입력 스트림에서 읽고 출력 스트림에 쓰는 작업은 표준화되어 있다. 즉, 사용되는 특정 스트림에 의존하지 않는다. 이는 동일한 Java 명령문을 사용하여 키보드, 파일 또는 인터넷에서 문자열을 읽을 수 있음을 의미한다. 이러한 작업은 다음 다이어그램에 표시된 클래스를 활용한다.

![Untitled](8%20Files%20and%20input%20output%20streams%20528e5885c2a147819d476dca74a2e624/Untitled%201.png)

## **Interleaving reading and writing**

interleaving은 사전적 의미로 끼워넣기 이다.

일반적으로 프로그램은 입력과 출력을 모두 수행하며interleaving 된다. *출력 작업은 출력 버퍼를* 통해 내부적으로 처리되며 , 프로그램과 상호 작용하는 사용자의 관점에서 인터리브된 입력 및 출력 기능이 제대로 작동하도록 하려면 다음 입력을 얻기 전에 출력 버퍼를 비워야 한다. 이는 OutputStream 개체 에 연결된 플러시 메서드를 사용하여 수행할 수 있다.

```jsx
public class Plural2 {
  public static void main(String[] args) throws IOException {
    InputStreamReader isr = new InputStreamReader(System.in);
    BufferedReader keyboard = new BufferedReader(isr);
    System.out.print("Insert a word: ");
    System.out.flush();
    String line = keyboard.readLine();
    System.out.println("The plural of " + line + " is " + line + "s.");
  }
}
```

## **Generalized input and output**

다음 프로그램에서는 이러한 스트림을 읽고 쓰는 작업에서 입/출력 스트림 생성을 분리하는 방법을 보인다.

```jsx
public class IOStreams {

  public static void readWrite(InputStream in, OutputStream out)
                                                         throws IOException {
    InputStreamReader isr = new InputStreamReader(in);
    BufferedReader br = new BufferedReader(isr);
    PrintStream ps = new PrintStream(out);
    String line = br.readLine();
    while (line != null) {
      ps.println(line);
      line = br.readLine();
    }
  }

  public static void main(String[] args) throws IOException {
    // Reads from the Internet and writes to a file
    System.out.println("*** Internet -> File ***");
    URL u = new URL("http://www.inf.unibz.it/");
    InputStream net = u.openStream();
    File fout = new File("CShome.html");
    FileOutputStream fileos = new FileOutputStream(fout);
    readWrite(net, fileos);
    fileos.close();

    // Reads from a file and writes to video
    System.out.println("*** File -> Video ***");
    File fin = new File("CShome.html");
    FileInputStream fileis = new FileInputStream(fin);
    readWrite(fileis, System.out);
    fileis.close();
  }
}
```

## **Static method for reading**

입력 채널(예: 텍스트 파일)에서 들어오는 데이터에 따라 객체를 생성하기 위해서는 입력 채널에서 데이터를 읽어 해당 데이터가 포함된 클래스의 객체를 생성하고 반환하는 정적 메서드를 정의하는 것이 일반적이다.

예를 들어, 클래스의 각 객체가 해당 이름과 성에 대한 정보로 특징지어지는 Person 클래스를 생각해 보면. 응용 프로그램에서 처리하려는 Person에 대한 정보가 각 Person 대해 다음과 같은 두 줄을 포함하는 텍스트 파일에 저장되어 있다고 가정한다

Person클래스에 다음과 같이 파일에서 데이터를 읽고 Person 객체를 생성하기 위한 정적 메서드응 정의할 수 있다. 

```jsx
import java.io.*;

public class Person {

  private String name, surname;

  public Person (String n, String c) {
    name = n; surname = c;
  }

  public static Person read (BufferedReader br) throws IOException {
    String s = br.readLine();
    if (s == null)
      return null;
    else
      return new Person(s, br.readLine());
  }
}
```