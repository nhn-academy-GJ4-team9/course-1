# Conditional statements

## Summary

- The  and  statements if-else and if statements
- Block of statements
- Conditional expression
- Comparison between objects
- The  switch statement

## **Conditional statements**

다른 모프로그래밍 언어와 마찬가지로 Java에는 조건을 확인하고 조건이 참인지 거짓인지에 따라 코드의 특정 부분을 실행할 수 있는 특정 명령문이 포함되어 있다. 이러한 명령문을 **conditional (조건문) 이라고 하며 composite statement**의 한 형태이다.

if-else 문은 두 가지 대안 중에서 선택한다.

여러 대안 선택하려면 swtich 문을 사용한다.

## **The if-else statement (If 조건문)**

if-else 문

```jsx
if (condition)
  then-statement
else
  else-statement
```

- condition은 boolean 유형이다. 즉, true 또는 false 로 평가되는 조건식이다.
- 평가 결과가 true이면 then-statement*가* 실행되고, 그렇지 않으면 else-statement 가 실행된다.

## **Condition in an if-else statement**

if-else 문의 조건은 boolean *유형의 임의 표현식이다.*

```jsx
1. boolean 변수;
boolean finished;
if (finished)

2. 비교 연산자 (==, !=, >, <, >=, or <=) 
int a, b, c;
if (a > b + c)

3. predicate 호출
String answer;
if (answer.equalsIgnoreCase("YES"))

4. ! , && 및 ||
int a, b, c, d;
String answer;
if ((a > (b+c)) || (a == d) && !answer.equalsIgnoreCase("YES"))

```

## **Block of statements**

**block of statements은 단일 명령문을 그룹화하여 순서대로 실행한다.**

```jsx
{
  statement
  ...
  statement
}
```

예시

```jsx
int a, b, bigger;
...
if (a > b) {
  bigger = a;
  System.out.println("smaller = " + b);
}
```

## **Scope of variables defined in a block**

b**lock of statements에는 변수 선언이 포함 될 수 있다. 변수 내부에서 선언된 변수는 외부에서 사용할 수 없다.**

예시

```jsx
public class ScopeInBlock {

  public static void main(String[] args) {
    String a = "Hello";
    int i = 1;
    {
      System.out.println(a);
           // OK. a is visible - prints Hello
      //int i;
           // ERROR. i is visibile and cannot be redeclared

      {
        double r = 5.5;          // OK
        i = i + 1;               // OK. i is still visible
        System.out.println(r);   // OK. r is visible - prints 5.5
      }

      //System.out.println(r); // ERROR. r is not visible
      System.out.println(i);   // OK. i is visibile - prints 2

      {
        int r = 4;       // OK. previous r is not visible anymore
        System.out.println(a);
                         // OK. a is still visibile - prints Hello
      }
    }

   i = i + 1;                  // OK. i is visible
   System.out.println(i);      // OK. i is visible - prints 3

  }
}
```

## **Nested if's - 중첩 if문**

if - else 문의 then-branch 또는 else-branch가 다시 if-else 또는 if 문일 때 중첩된 if가 있다.

예시 : 일, 월 , 연도가 주어지면 다음 날의 일, 월, 연도를 구한다.

```jsx
int day, month, year, nextDay, nextMonth, nextYear;
...
if (month == 12) {
  if (day == 31) {
    nextDay = 1;
    nextMonth = 1;
    nextYear = year + 1;
  } else {
    nextDay = Day + 1;
    nextMonth = month;
    nextYear = year;
  }
} else {
  ...
}
```

## **Nested if's with mutually excluding conditions**

중첩된 if의 일반적인 사용은 중첩된 if의 조건이 상호 배제되는 경우이다. 즉, 두 조건이 동시에 참일 수는 없다.

| temperature t | message |
| --- | --- |
| 30 < t | hot |
| 20 < t < = 30 | warm |
| 10 < t < = 20 | fine |
| t < = 10 | cold |

```jsx
int temp;
...
if (30 < temp)
  System.out.println("hot");
else if (20 < temp)
  System.out.println("warm");
else if (10 < temp)
  System.out.println("fine");
else
  System.out.println("cold");
```

## **Example: 삼각형 유형**

삼각형의 세 변의 길이를 나타내는 세 가지 값이 주어지면 삼각형이 정삼각형(세 변이 모두 같음), 대칭형(두 변이 모두 같음) 또는 불규칙형(두 변이 모두 동일하지 않음)인지 확인해야 한다.

삼각형의 유형을 결정하는 데 충분한 정보를 수집할 때까지 변을 2개씩 비교하면 된다..

알고리즘은 다음과 같다

```jsx
double first, second, third;
...
if (first == second) {
  if (second == third)
    System.out.println("표준");
  else
    System.out.println("대칭");
} else {
  if (second == third)
    System.out.println("대칭");
  else if (first == third)
    System.out.println("대칭");
  else
    System.out.println("불규칙");
}
```

## **Shortcut evaluation of a complex condition**

((boolean1) && (boolean2)) 를 평가할때 boolean1 이 false 이면 boolean2의 값과 상관 없이 boolean는 평가되지 않는다. 일반적으로 *Java*가 **부울 **표현식의 **간단한 **평가를 **수행한다는 **사실을 **고려해야 **하며 **무시할 **수 **없다 왜냐하면 코드의 정확성이 이에 따라 달라질 수 있기 때문이다.

일반적으로 복잡한 조건을 사용하는 if-else 문은 중첩된 if-else 문을 사용하여 다시 작성할 수 있다

코드

```
if ((x < y) && (y < z))
  System.out.println("y는 x와 z 사이에 있습니다.");
else if
  System.out.println("y는 x와 z 사이에 없습니다.");
```

```
if (x < y)
  if (y < z)
    System.out.println("y는 x와 z 사이에 있습니다.");
	else if
    System.out.println("y는 x와 z 사이에 없습니다.");
else if
  System.out.println("y는 x와 z 사이에 없습니다.");
```

## **selection operator**

자바에서 조건식을 구성할 수 있는 **selection operator(선택 연산자)가 있다.**

조건식을 사용하는 경우에 따라 if-else 문 사용과 관련하여 코드가 단순화 될 수 있다.

표현식 :*condition* ? *expression-1* : *expression-2*

조건을 평가한다 . 결과가 true 이면 *expression-1* 을 평가하여 해당 값을 반환하고,

 그렇지 않으면 *expression-2를* 평가 하고 해당 값을 반환한다

예시 :

```jsx
 System.out.println("더 큰 값 = " + (a > b)? a : b);
```

조건식을 사용하는 예제의 명령문은 다음과 동일하다.

```jsx
if (a > b)
  System.out.println("더 큰 값 = " + a);
else if
  System.out.println("더 큰 값 = " + b);
```

위와 같이 선택 연산자는 if-else 문과 유사 하지만 다른 구문 수준에서 작동한다.

## **Note : equality between strings - 문자열 간의 비교**

두 **문자열*(*즉*, String* 클래스의 두 객체)이 동일한지 테스트하려면 **equals 메소드를** 사용해야 한다 . == 를 사용하는 것은 잘못된 것이다

예시

```jsx
String s = new String("pippo");
String t = new String("pippo");
String w = s;

System.out.println("s == w? " + s == w);           // TRUE
System.out.println("s == t? " + s == t);           // FALSE
System.out.println("s equals t?" + s.equals(t));   // TRUE
```

## **Note : lexicographic comparison between strings - 문자열 사전식 비교**

다음과 같은 경우 문자열 *s*가 ****사전순** 으로 문자열 *t* 보다 **앞에 온다

s 는 t의 접두사 이거나 만약 ‘a’ 와 ‘b’가 각 각 s와 t의 첫문자 인 경우 ‘a’ 가 ‘b’보다 앞에 온다

참고 : 알파벳 문자인 경우 문자 순서는 알파벳 순서와 일치하며. 숫자는 문자 앞에, 대문자는 소문자보다 앞에 온다.

예시 :

> house가 household 보다 앞에 있다.
> 

> Household 가 house 보다 앞에 있다.
> 

> composer 가 computer보다 앞에 있다
> 

> H2O 가 Hotel 보다 앞에 있다
> 

문자열이 사전순으로 다른 문자열보다 앞에 있는지 확인하려면 **CompareTo** 메서드를 사용한다. 

두 개의 문자열 s 와 t 가 주어지면 s.compareTo(t)는 아래와 같이 반환한다.

> s가 t 보다 앞에 있으면 음수이다.
> 

> s와 t 가 같다면 0 이다.
> 

> s가 t 보다 뒤에 있으면 양수이다
> 

## **Note on comparisons: equality between objects - 객체 간의 동등성**

문자열의 경우 클래스의 두 개체가 같은지 테스트하려면 == 를 사용할 수 없다 . 

두 개체에 대한 참조의 동일성을 테스트하기 때문이다. 

대신, 클래스 객체의 구조를 고려한 적절한 방법을 정의해야 한다.

Unit 4에서 개발한 BankAccount 클래스를 참조하면 이러한 클래스에 두 은행 계좌를 비교하는 데 사용할 수 있는 조건부 equalTo 정의를 추가할 수 있다.

```jsx
public boolean equalTo(BankAccount ba) {
  return this.name.equals(ba.name) &&
         this.surname.equals(ba.surname) &&
         this.balance == ba.balance;
}
```

즉, 두 개의 은행 계좌가 소유자의 이름과 성이 일치하고( 문자열에 대해 equals 메소드를 사용하여 확인) 잔액이 동일한 경우( 잔고가 다음 과 같으 므로 == 를 사용하여 확인) 동일한 것으로 간주된다.

```jsx
BankAccount ba1 = new BankAccount("Mario", "Rossi");     // balance is 0
BankAccount ba2 = new BankAccount("Carla", "Verdi");     // balance is 0
BankAccount ba3 = new BankAccount("Carla", "Verdi");     // balance is 0
BankAccount ba4 = ba2;

System.out.println("ba1 and ba2 equal?    " + ba1.equalTo(ba2));  // NO
System.out.println("ba2 and ba3 equal?    " + ba2.equalTo(ba3));  // YES
System.out.println("ba2 and ba3 coincide? " + ba2 == ba3);        // NO
System.out.println("ba2 and ba4 equal?    " + ba2.equalTo(ba4));  // YES
System.out.println("ba2 and ba4 coincide? " + ba2 == ba4);        // YES
```

## **Note : comparison with null - null 값 비교**

어떤 객체도 참조하지 않는 객체에 대한 참조 유형의 변수는 값이 null 이라는 것을 기억해보면 
if-else 문의 조건에서 null 과의 비교를 사용할 수 있다. 

null 과 비교하려면 ==를 사용해야 하고 equals 메소드는 사용하지 않아야 한다

예: 사용자가 '취소' 버튼을 누르면 showInputDialog는 null을 반환한다

```
String input = JOptionPane.showInputDialog("...");
if (input != null) { ... }
```

## 연습문제 : **BankAccount 클래스 수정**

충분한 돈을 사용할 수 있는 경우에만 인출이 수행되도록 단원 4에서 개발한 은행 계좌를 처리하도록 클래스를 수정한다. 

다음 메서드도 추가해야 한다.

- BankAccount 클래스의 두 객체가 동일한 소유자(즉, 동일한 이름과 성)를 가지고 있는지 확인하는 sameOwner 메서드
- 은행계좌와 금액이 주어지면 해당 금액을 은행계좌로 이체하되, 이체할 자금이 부족한 경우에도 처리하는 이체 메서드
- 이체(transfer)방식은 은행계좌와 금액이 주어지면 은행계좌에서 금액을 이체하는 방식으로, 이체할 자금이 부족한 경우에도 처리한다.

테스트 예시

```jsx
public class TestBankAccount {

  public static void main(String[] args) {
     BankAccount ba1 = new BankAccount("Mario", "Rossi");
     BankAccount ba2 = new BankAccount("Carla", "Verdi");
     BankAccount ba3 = new BankAccount("Carla", "Verdi");
     System.out.println("Do ba1 and ba2 have the same owner? " +
                        ba1.sameOwner(ba2));
     System.out.println("Do ba2 and ba3 have the same owner? " +
                        ba2.sameOwner(ba3));
     ba1.deposit(1000);
     ba2.deposit(500);
     ba3.deposit(750);
     System.out.println("Before the transfer ...");
     System.out.println(ba1);
     System.out.println(ba2);
     ba1.transferTo(ba2, 250);
     System.out.println("After the transfer...");
     System.out.println(ba1);
     System.out.println(ba2);
  }
}
```

## 해결

```jsx
public class BankAccount {
  private String name, surname;
  private double balance;

  ...

  public void withdraw(double val) {
    if (val <= balance)
      balance -= val;
    else
      System.out.println("Not sufficient money for withdrawal");
  }

  public boolean sameOwner(BankAccount ba) {
    return this.name.equals(ba.name) &&
           this.surname.equals(ba.surname);
  }

  public void transferTo (BankAccount ba, double val) {
    if (val <= this.balance) {
      this.withdraw(val);
      ba.deposit(val);
    } else
      System.out.println("It is not possible to withdraw " + val +
                         " Euro from account " + this);
  }

  public void transferFrom (BankAccount ba, double val) {
    if (val <= ba.balance) {
      ba.withdraw(val);
      this.deposit(val);
    } else
      System.out.println("It is not possible to withdraw " + val +
                         " Euro from account " + ba);
  }
}
```

## **The switch statement (Swtich 문)**

**객관식 선택을** 구현해야 하는 경우 여러 개의 중첩된 if-else 문을 사용할 수 있다. 

Java 에는 객관식 선택을 더 간단한 방법으로 실현하기 위해 특정 경우에 사용할 수 있는 Switch 문이 존재한다.

```jsx
switch (expression) {
  case label-1: statements-1
                 break;
  ...
  case label-n: statements-n
                 break;
  default: default-statements
}
```

- 표현식은 정수 유형 또는 문자 유형의 표현식이다.
- *label-1* ,..., *label-n*은 상수 정수(또는 문자) 표현식이다. 즉, 표현식에는 정수(또는 문자) 리터럴이나 상수 표현식으로 초기화되는 상수만 포함될 수 있다. 서로 다른 두 라벨의 값은 일치해서는 안된다.
- 문*1* ,..., **문*n* 은 임의의 시퀀스이다.
- 기본 부분은 선택 사항임

예시

1. 먼저 expression이 평가된다.
2. 그런 **다음 *label-i* 값이 표현식 값과 동일한 첫 번째 *i* 를 찾는다 .
3. 동일한 i 가 있으면 명령문  i 가 실행된다.
그렇지 않으면 default **명령문이 실행된다.
4. switch 문 바로 다음 문으로 실행이 계속된다.

사용 예

```jsx
int i;
...
switch (i) {
  case 0: System.out.println("zero"); break;
  case 1: System.out.println("one"); break;
  case 2: System.out.println("two"); break;
  default: System.out.println("less than zero or greater than two");
}
```

i 가 0(각각 1, 2)이면 "zero" (각각 "one" , "two" )가 인쇄된다 i 가 0보다 작거나 2보다 크면 "0보다 작거나 2보다 큽니다"가 인쇄된다

동일한 명령문을 실행하려는 expression 의 값이 두 개 이상인 경우 서로 다른case를 그룹화 할 수 있다 .

```jsx
case label-1: 
	case label-2: statements
break;
```

## **Example of switch statement**

스위치문 예시 : 해당 월의 날짜를 계산한다.

```jsx
int month, daysOfMonth;
...
switch (month) {
case 4: case 6: case 9: case 11:
  daysOfMonth = 30;
  break;

case 1: case 3: case 5: case 7: case 8: case 10: case 12:
  daysOfMonth = 31;
  break;

case 2:
  daysOfMonth = 28;
  break;

default:
  daysOfMonth = 0;
  System.out.println("Month is not valid");
}

System.out.println("Days: " + daysOfMonth);
```

## **Observation on the switch statement**

선택에 사용되는 표현식은 정수 또는 문자 값(부동 소수점 값은 아님)을 반환하는 임의의 Java 표현식 일 수 있다. 다양한 케이스에 의해 지정된 값은 상수 표현식 이어야 한다.. 즉, 그 값은 *compile time*에 지정되야한다 . 특히 변수를 참조하는 표현식이 될 수 없다.
다음 코드는 에러가 있다.

```jsx
int a;
...
switch (a) {
  case a<0: System.out.println("negative");
                                 // ERROR!  a<0 is not a constant expression
  case 0:   System.out.println("zero");
  case a>0: System.out.println("positive");
                                 // ERROR!  a>0 is not a constant expression
}
```

따라서 *switch* 문의 유용성은 제한된다.