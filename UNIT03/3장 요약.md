# 3장

## 모듈화

- 프로그램의 개발이 매우 길고 복잡해짐에 따라, 프로그램의 복잡도를 관리하기 위해 프로그램을 모듈화하여 구현한다.

  - 모듈: 자율적으로 나누어진 프로그램의 한 부분
  - 다양한 모듈은 정확한 상호 관계로 연결되어 있는다.

### 모듈의 특성

- 모듈이 다른 모듈이 요청하는 기능을 수행할 수 있습니다.
- 모듈의 작동 결과를 전해줌으로써 각 모듈의 인터페이스 역할을 합니다.
- 다른 모듈이 클라이언트의 역할로 모듈의 동작을 필요로 합니다.
- 모듈의 동작 방식을 알 수 없습니다.

### 프로그램에 모듈화를 적용하는 과정

1. 문제를 해결하는데 필요한 모듈들이 무엇인지 정의합니다.
2. 각 모듈이 어떻게 관련되어 있는지 정의합니다.
3. 모듈을 개발할 때, 다른 모듈과 독립적으로 개발해야 합니다.

- (1개의 모듈은 독립적으로 실행 가능해야함.)

### 모듈화를 통해서 향상시킬 수 있는 부분

- 가독성, 이해가능성
- 확장성 (프로그램의 기능을 확장할 수 있는 가능성)
- 재사용성 (다양한 목적으로 해당 모듈을 다른 프로그램에 적용가능)

## 추상화

- 모듈화와 상당한 관련이 존재함.
- 문제를 해결할 때, 문제를 추상화하고 문제 해결을 위한 솔루션을 구성합니다.

  - 문제의 본질을 파악하는데 집중
  - 달성하고자 하는 목표와 다른 부분을 배제

### 추상화 유형

1. 동작에 대한 추상화(Abstraction on operations)

   - 어떻게 구현하는지가 아닌, 무엇을 구현하는지가 중요하다.

   - 메서드(Method): 자바에서 연산을 추상화하는 방식

     - 매게변수를 입력으로 연산하여 결과를 반환하거나 작업을 수행하는 블랙박스로 간주
     - 함수 VS 메서드?

   - 모듈로 표시되는 메서드

     - exported services: 메서드가 무엇을 구현하는가?, 메서드의 결과가 무엇인가?
     - exported services: 해당 메서드를 구현하는데 사용되는 다른 메서드 및 클래스
     - interface: 메소드 헤더(Type Signiture)로 유형을 지정할 수 있음.
     - internal structure: 메서드가 구현하고자 하는 기능을 어떻게 설명하는가?

   - 메서드의 정의

     - 문법적(Syntax)

       - 접근 지정자
       - 바인딩 한정자 (static), (final) 등
       - 반환 타입 (Return Type)
       - 메서드의 이름
       - 매게변수들

       - Statement Block { ... }

     - 의미적(Sementic)
       - 헤더
         - 매서드 이름, 리턴 타입, 매개변수의 개수 및 타입
       - 본문
         - 메서드가 호출될 때, 실행되어야 하는 명령문의 묶음
         - 매개변수의 이름을 가지고 본문 내에서 해당 변수에 접근이 가능함.
         - 반환된 결과는 메서드 호출의 결과로서 사용된다.

- static method 예시

```java
public static void printGreeting() {
  System.out.println("Good morning!");
}
```

```java
public static void printPersonalGreeting(String firstName, String lastName) {
  System.out.print("Good morning ");
  System.out.print(firstName);
  System.out.print(" ");
  System.out.print(lastName);
  System.out.println("!");
}
```

- return문 예시
  - 결과를 반환하는데 사용하는 자바 명령어, 뒤에 반환하고자 하는 값을 넣으면 된다.

```java
public static String personalGreeting(String firstName, String lastName) {
  return "Good morning " + firstName + " " + lastName + "!";
}
```

- 매개변수 전달

  - 형식 매개변수에 실제 매개변수를 넣어주어, 활성화 시키면 컴파일러가 자동으로 바인딩 해줌.

```java
public class Parameters{
  public static void changeValueS (String s) {
    s = s.concat("*");
  }

  public static void changeValueSB (StringBuffer sb) {
    sb.append("*");
  }

  public static void main(String[] args) {
    String a = "Hello";
    StringBuffer b = new StringBuffer("Ciao");

    System.out.println("String a = " + a);
    System.out.println("StringBuffer b = " + b);

    changeValueS(a);
    changeValueSB(b);

    System.out.println("String a = " + a);
    System.out.println("StringBuffer b = " + b);
  }
}
```

```
  String a = Hello
  StringBuffer b = Ciao
  String a = Hello
  StringBuffer b = Ciao*
```

(사진)

- 지역 변수 (Local Variables)
  - 메서드의 본문에 선언되는 변수 (모든 Body에서 사용되는 변수는 지역 변수입니다.)
  - 범위 (정적인 개념)
    - 변수의 이름으로 주소나 값에 접근할 수 있는 영역을 지칭함.
    - { ... } 으로 지정됨. 중괄호 안에서 선언된 변수는 해당 영역 밖에서 사용할 수 없음.

```java
public class Visibility {

  public static String duplicate(String s) {
    String t = s + ", " + s;
    return t;
  }

  public static void print1() {
    System.out.println(a);   //ERROR: a is not defined
  }

  public static void print2() {
    System.out.println(t);   //ERROR: t is not defined
  }

  public static void main(String[] args) {
    String a = "Ciao";
    a = duplicate(a);
    print1();
    print2();
    System.out.println(a);
  }
}
```

    - 수명 (동적인 개념)
      - 변수가 메모리에 상주하고 있어 프로그램 실행 중에 접근할 수 있는 시간을 의미함.
      - 메서드가 호출되고 결과가 반환되면 변수는 소멸한다.
      - 메서드를 새로 호출하면 새로운 메모리 위치에 변수가 할당되므로 변수의 내용이 변한다.

    - 메서드 오버로딩 (Overloading of methods)
      - 형식 매개변수의 개수나 타입이 다르면 컴파일러가 두 메서드를 구분, 다른 동작을 수행
      - 매개변수의 이름은 관련이 없음.
      - Type Signiture가 다르면 오버로딩? (따로 수행해 보는 것이?)

```java
public class Greetings2 {

  public static void printGreeting() {
    System.out.println("Hello!");
  }

  public static void printGreeting(String name) {
    System.out.println("Hello " + name + "!");
  }
}
```

- 두 메서드의 형식 파라미터의 개수에 차이가 존재, 서로 다른 기능을 수행하는 메서드로 컴파일

2. 객체에 대한 추상화(Abstraction on objects)

   - 유사한 객체를 모아, 공통된 부분을 클래스로 그룹화 합니다.

     - 객체의 관련 속성, 객체가 지원하는 작업을 설정한다.

   - 자바에서의 클래스 정의

     - 클래스 자체를 식별, 클래스에 속하는 인스턴스의 유형을 식별: 클래스 이름
     - 객체 내부에 데이터를 저장할 수 있는 변수: 인스턴스 변수, 데이터 필드
     - 클래스 객체에 대해 호출할 수 있는 작업: 클래스 메서드

   - 접근 지정자 (access modifier)

     - 클래스 외부에서 접근하는 사용자 (클라이언트)에게 표시하는 영역을 정의
     - 클라이언트와 관련이 없는 부분은 숨겨야 하기 때문에 사용한다.

   - 종류

     - Public: 전체 클라이언트이 접근이 가능
     - Protected: 같은 패키지에서 상속관계에서 접근이 가능
     - Default: 같은 패키지에서만 접근이 가능
     - Private: 클래스 내부에서만 접근이 가능

   - 클래스를 모듈로 보면?

     - exported services: 공용 메서드, 클래스 외부에서 사용이 가능한 메서드
     - interface: 공개된 메서드의 헤더
     - imported services: 객체 및 클래스의 메서드를 구현, 사용되는 메서드 및 클래스
     - internal structure: 객체와 메서드를 구현

   - 클래스의 정의
     - 클래스 이름
     - 필드
       - 상태: 객체의 내부 구조를 나타내는데 사용
       - 메서드: 객체의 동작을 구현하는데 사용

```java
public class Person {
  //instance variables (data fields)
  private String name;
  private String residence;

  //methods (operation fields)
  public String getName() {
    return name;
  }
  public String getResidence() {
    return residence;
  }
  public void setResidence(String newResidence) {
    residence = newResidence;
  }
}
```

```java
public class ClientClassPerson {
  public static void main(String[] args) {
    Person p1;
    p1 = new Person();
    p1.setResidence("Roma");
    System.out.println(p1.getResidence());
  }
}
```

- 정의된 클래스를 사용

  1. 클래스 타입의 지역 변수를 정의
  2. 객체를 생성하고 해당 지역변수에 Assign
  3. 객체에 대하여 메서드나 상태를 참조 (Selection Operator) 사용

- 인스턴스 변수

  - 클래스 내부에 정의되어 있지만, 클래스 외부에서 사용할 수 있는 변수 입니다.
    1. 모든 메소드 밖에서 정의됩니다.
    2. access modifier가 앞에 와서 사용됩니다.
    3. 객체가 생성될 때 암시적, 명시적으로 초기화

(사진)

- 인스턴스 변수의 범위

  - 인스턴스 변수는 메서드에서 항상 표시할 수 있는 변수 (단 객체가 선언되는 범위가 중요)
  - public 접근 지정자가 붙었다면, 인스턴스 변수를 가져올 수 있음.

- 인스턴스 변수의 수명

  - 객체의 수명과 정확하게 일치 (객체가 메모리에 상주해 있는 시간을 의미)

- 암시적인 형식 매개변수 this
  - this는 호출 객체를 가르키는 형식 매개변수이다.
  - 인스턴스 변수, 메서드를 사용할 때마다 컴파일러가 알아서 붙여줌. (가독성과 이해의 향상으로 사용)

```java
public class Person {
  private String name;
  private String residence;

  public String getName() {
    return name;
  }
  public String getResidence() {
    String residence;
       // the local variable masks the instance variable with the same name
    residence = this.residence;
       // this is used to distinguish the instance var from the local var
    return residence;
       // here we are referring to the local variable
  }
  public void setResidence(String residence) {
    this.residence = residence;
       // this is again used to distinguish the instance var from the local var
  }
}
```

- 생성자(Constructor, ctor)
  - 객체를 적절하게 초기화하는 방법
  - 객체가 생성될 때, 자동으로 실행되는 메서드
  - 반환 형식과 반환 문을 사용하지 않음.

```java
Person p = new Person("John Smith", "London"); // constructor name-residence is called
System.out.println(p.getResidence()); // prints "London"
```

- 생성자도 메서드의 일종이므로 오버로딩이 가능함.
- Standard Constructor (기본 생성자?)

  - 클래스에 생성자가 정의되지 않았다면 컴파일러가 자동으로 생성
  - 클래스에 생성자가 정의되어 있다면 생성되지 않음.

- 클래스를 구현하는 방법

  1. 클래스를 정의하고 구현하고자 하는 속성과 동작을 식별
  2. 필요한 인스턴스 변수를 식별, 객체를 대한 표현을 선택 (Getter, Setter)
  3. 클래스의 공개 메서드 헤더를 선택 (생성자, 기능 구현)
  4. 반복되고 다른 메소드로 분할 할수있는 부분을 분할 할 것 (구현한 기능을 분할)

- 클래스 클라이언트

  - 클래스의 공개 메서드가 어떠한 기능을 수행하는가?에 초점
  - 위의 단계 중 3단계를 클래스의 골격이라함.

- 상속
  - 객체 지향 프로그래밍의 특성
  - 상위 클래스(super, base)의 필드를 하위 클래스(sub, derived)에서 사용가능

```java
public class Student extends Person {
  private String faculty;

  public Student(...) {   // constructor
    ...
  }

  public String getFaculty() {
    return faculty;
  }
}
```

- 하위 클래스의 특징

  - 상위 클래스의 모든 데이터 필드와 연산에 접근 할 수 있다.
  - 상위 클래스를 사용할 수 있는 곳에는 하위 클래스도 사용할 수 있다. (LSP?)
  - 상위 클래스는 하위 클래스의 객체에 접근 할 수 없다. (상속의 역은 성립 X)

- 하위 클래스의 생성자

  - 하위 클래스의 생성자를 정의할 때, 제일 먼저 상위클래스를 호출하여야 한다.
  - 예시의 super 메서드를 통해서 상위 클래스의 생성자를 호출한다.
  - 만약 super 메서드가 없을 경우, Standard Constructor를 실행함.
    - 오류를 방지하기 위해서 매게변수를 받는 생성자에서는 무조건 super 메서드를 호출할 것

- 호환성 (상위 클래스의 타입에 하위 클래스를 사용할 수 있음 왜? 하위 클래스도 상위 클래스의 항목을 가지고 있음)
  - 하위 클래스는 상위 클래스의 타입에 호환가능함.
  - 그 반대는 캐스팅을 통해서 접근이 가능하지만, 안전성을 보장하지 않음.

```java
public class TestCompatibility {
  public static void main(String[] args) {
    Person p = new Person("Daniele", "Roma");
    Student s = new Student("Jacopo", "Roma", "Engineering");
    Person pp;
    Student ss;
    pp = s;    //OK! Student is compatible with Person
    ss = p;    //ERROR! Person is not compatible with Student
    System.out.println(pp.getName());
               //OK! getName() is a method of Person
    System.out.println(pp.getResidence());
               //OK! getResidenza is a method of Person
    System.out.println(pp.getFaculty());
               //ERROR! getFaculty is not a method of Person
  }
}
```

- 하위 클래스는 상위 클래스의 모든 공개된 데이터와 연산에 접근할 수 있음.

- 메서드 재정의 (Method Override)

  - 동일한 타입 시그니처(메서드 헤더)를 가지고 서브 타이핑 관계에서 성립함.
  - 동일한 타입 시그니처에 다른 기능을 수행하는 다형성(polymorphism)이 보장됨.

- 서브 타이핑과 Composition

  - 서브 타이핑: 상속을 통해서, 상위 클래스의 모든 요소를 사용
  - Composition: 1개 클래스에 다른 클래스의 타입 객체를 가져와서 공개된 요소를 사용

  - X 의 각 객체가 Y 의 객체인 경우 ( X IS-A Y ) 상속을 사용합니다.
  - Y 의 각 객체에 X 의 객체가 있는 경우 ( Y HAS-A X ) 합성을 사용합니다.
