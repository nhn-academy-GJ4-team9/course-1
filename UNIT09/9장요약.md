# 프로그램 오류 및 예외처리

### 프로그램 오류 유형
1. 구문 오류: 언어 구문이 존중되지 않아 발생하는 오류입니다.
2. 의미오류(Semantic error): 프로그램 문장의 부적절한 사용으로 인한 오류.
3. 논리적 오류: 명세를 따르지 않아서 발생하는 오류.
4. 컴파일 시간 오류: 컴파일러가 나타내는 구문 오류 및 정적 의미 오류입니다.
5. 런타임 오류: 컴파일러(디버깅)에서 감지할 수 없는 동적 의미 오류 및 논리 오류입니다.

### 구문 오류
- 구문오류는 java 언어의 구문이 존중되지 않기 떄문에 발생합니다.

```java
// 예시 1: 세미콜론(;) 누락

int a = 5 // semicolon is missing

//예시 2: 표현식의 오류

x = ( 3 + 5;  // missing closing parenthesis ')'
y = 3 + * 5;   // missing argument between '+' and '*'

```
### 의미론적 오류
- 의미오류는 java문의 부적절한 사용을 나타냅니다.

의미론적 오류의 예시입니다.
```java
// 예시 1: 초기화되지 않은 변수 사용
int i;
i++;    // 변수 i가 초기화 되지 않았습니다.

// 예시 2: 유형 비호환호성
int a = "hello"; // String과 int 유형은 호환되지 않습니다.

// 예시 3: 표현식의 오류
String s = "...";
int a = 5 - s;  // - 연산자는 String 유형의 인수를 지원하지 않습니다.

//예시 4: 알수 없는 참조
Strin x;                     // 문자열이 정의되지 않았습니다.
system.out.println("hello"); // 시스템이 정의되지 않았습니다.
String s;
s.println();        // println은 String 클래스의 메서드가 아닙니다.
//예시 5: 배열 인덱스가 범위를 벗어났습니다.(동적 의미 오류)

int[] v = new int[10];
v[10] = 100;           // 10은 10개 요소의 배열에 대한 유효한 인덱스가 아닙니다.
// 배열은 10개의 요소(0~9범위의 인덱스 포함)로 생성 되었으며 존재하지 않는 인덱스 10의 효소에 액세스 하려고 합니다.
// 이러한 유형의 오류는 컴파일 중에는 발견되지 않지만 런타임 시 예외가 발생하게 합니다.
```

### 논리적 오류
- 논리적 오류는 소프트웨어 사양이 존중되지 않기 때문에 발생합니다. 프로그램이 오류 없이 컴파일되고 실행되지만 요청한 결과가 생성되지 않습니다.

논리적 오류의 몇 가지 예시 입니다.
```java
//예시 1: 수행된 계산의 오류
public static int sum(int a, int b) {
  return a - b ;
}

// 이 메서드는 필요한 사양에 따라 잘못된 값을 반환합니다.
// 예시 2: 비종료
String s = br.readLine();
while (s != null) {
  System.out.println(s);
}// 이 루프는 종료되지 않습니다.
```

### 컴파일러에서 감지한 오류 및 런타임 오류
- 모든 구문오류와 일부의미 오류(정적 의미 오류)는 컴파일러에 의해 감지됩니다.
- 컴파일러는 오류유형과 오류가 발생한 java소스 파일의 위치를 나타내는 메시지를 생성합니다.
- 기타 의미 오류(동정 의미 오류) 와 논리 오류는 컴파일러에서 감지할 수 없으므로 프로그램이 실행될 떄만 감지됩니다.

런타임 시 감지된 오류의 몇 가지 예시입니다.
```java
//예시 1: 0으로 나누기
int a, b, x;
a = 10;
b = Integer.parseInt(kb.readLine());
x = a / b;  //b = 0 이면 오류발생
// 이 오류는 입력의 특정 구성(b = 0)에서만 발생합니다.

//예시 2: 파일이 존재하지 않습니다.
FileReader f = new FileReader("pippo.txt");
// 이 오류는 pippo.txt 파일이 하드 디스크에 없는 경우에만 발생합니다.

//예시 3: Null 참조 역참조:
String s, t;
s = null;
t = s.concat("a");
// 값이 null인 참조에는 concat 메서드를 적용할 수 없습니다. 위 코드는 concat 메소드가 String유형의 참조에 올바르게 적용되었기 때문에 구문상으로는 정확하지만, 값이 null인 참조에 메소드를 적용할 수 없다는 사실로 인해 동ㅂ적 의미 오류가 포함되어 있습니다.
```

### 테스트용 드라이버
- 테스트용 드라이버는 클래스나 메서드의 적확성을 테스트하는 데 사용되는 프로그램 부분입니다. 이러한 드라이버의 목적은 클래스이 공용인터페이스에 대한 모든 메서드를 호출하고 해당 메서드가 사양을 준수하는지 확인하는 것 입니다.

1. 각기능(각 방법)을 확인합니다.
2. 특정 순서에 따라 테스트를 수행합니다.(방법 적용 순서가 중요한 경우가 많습니다.)
3. 각 명령문이 적어도 한 번은 실행되는지 확인합니다. 예를 들어 조건문이 있는 경우 boolean조건이 각각 참과 거짓이 되는 방식으로 입력의 다양한 구성에 대한 데스트를 수행 해야 합니다.
4. 특별한 경우(예: 파일에서 읽는 메서드에 대한 입력으로 빈파일)를 감지하고 테스트합니다.

### 오류감지(디버깅) 기술
- 테스트 단계에서 논리적 오류가 있음을 알리거나 런타임 오류의 원인을 감지할 수 없는 경우 프로그램을 디버깅 해야합니다.

1. 코드에 출력 문을 삽입하여 디버깅 합니다.
2. 디버거를 통해 프로그램을 실행함으로써 디버깅합니다.

### 출력 문을 삽입하여 디버깅
- 이 디버깅 기술은 오류를 일으키는 잘못된 값을 포함할 수 있는 변수의 내용을 인쇄하는 소스 코드 문의 적절한 위치에 삽입하는 것을 기반으로 합니다.

```java
int a, b, x;
a = 5;
b = Integer.parseInt(kb.readLine()); // b 읽기
...         // 변경되지 않는 명령문 b
x = a/b;

// 이 프로그램 명령문을 디버깅하기 위해 b값을 화면에 인쇄하여 변수 b 값이 0일 때 오륙 발생하는지 확인할 수 있습니다.

int a, b, x;
a = 5;
b = Integer.parseInt(kb.readLine()); // b 읽기
...         // 변경되지 않는 명령문 b
System.out.println("b = " + b);
x = a/b;
```

- 오류의 원인이 식별되고 수정되면 디버깅 세션을 닫기 전에 인쇄 문을 제거할 수 있습니다.
- 기본 데이터 유형의 단순한 변수가 아닌 객체의 내용을 탐색해야 하는 경우 객체의 내용에 대한 정보를 제공하는 toString 메소드를 사용할수 있습니다.
- 디버깅 하는동안 개체 상태 읽기를 단순화하기 위해 toString을 재정의 할 수도 있습니다.

### 디버거를 이용한 프로그램 실행
디버거를 사용하면 다음을 수행할 수 있습니다.

- 한 번에 하나씩 프로그램의 명령문을 실행합니다.
- 실행이 사용자가 정의한 특정 지점에 도달할 때까지 프로그램을 실행합니다.
- 실행 중 언제든지 변수와 개체의 내용을 검사합니다.

```java
//에시 1:
int a, b, x;
a = 5;
b = Integer.parseInt(kb.readLine()); // b 읽기
...         // b를 변경하지 않는 명령문
x = a/b;
// 디버거를 통해 오류를 생성하는 명령문을 실행하기 전에 변수 b의 값을 확인 할 수 있습니다.
// 예시 2:
String s, t;
s = null;
...
t = s.concat("a");
```
- t에 대한 할당문은 NullPointerException 유형의 예외를 생성합니다. 이러한 오류는 대입문이 실행될 때 null 이라는 사실에 따라 달라집니다.
- 이 오류를 확인하려면 오류를 생성하는 명령문을 실행하기 전에 디버거를 사용하고 변수 s의 값을 관찰하면 됩니다.

### 프로그램 실행 중 오류처리
```java
Example: Consider the following program:

public class TestException {
  public static void main (String[] args) {
    int falseNumber = Integer.parseInt("OK");
    System.out.println("this println statement is not executed");
  }
}
//다음 메시지가 화면에 인쇄됩니다.
Exception in thread "main" java.lang.NumberFormatException: For input string: "OK"
  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:48)
  at java.lang.Integer.parseInt(Integer.java:468)
  at java.lang.Integer.parseInt(Integer.java:518)
  at TestException.main(TestException.java:3)
// 따라서 "이 println 문은 실행되지 않습니다" 라는 문자열이 인쇄되지 않습니다.
```

- java에서는 런타임 시 발생하는 오류를 예외로 표현합니다. java는 프로그램 실행 중에 발생할 수 있는 사전 정의된 예외 세트를 제공합니다.
- 프로그램이 예기치 않게 종료되는 것을 방지하기 위해 java에서는 적절한 구성을 통해 예외를 처리할 수 있습니다.

### 예외의 계층 구조
- 예외 및 오류는 java 클래스를 통해 표시되며 계층 구조로 구성됩니다.
- Throwable 클래스는 모든 유형의 오류와 모든 예외의 슈퍼클래스 입니다. 오류는 프로그래머가 제어할 수 없는 이벤트를 나타내는 반면, 예외는 프로그램 실행중에 처리될 수 있습니다.

### 예외 처리 방법
- 생성된 예외 처리
- 프로그램의 다른지점에서 예외 처리

대신 예외가 처리되지 않으면 프로그램이 종료되고 메시지가 인쇄됩니다.

### 가장 일반적인 예외 유형

1. NullPointerException : 메서드를 호출하는 데 사용된 참조의 값이 null 이거나 null 참조 를 통해 인스턴스 변수에 액세스하려고 할 때 생성됩니다 . 일부 메서드는 null 인 매개 변수가 전달될 때 명시적으로 이러한 유형의 예외를 발생시킵니다.
2. ArrayIndexOutOfBoundsException : 0보다 작거나 배열 길이에서 1을 뺀 값보다 큰 인덱스를 사용하여 배열 요소에 액세스할 때 생성됩니다.
3. IOException : 오류 상황이 발생했을 때 입출력 장치에 접근하는 메소드에 의해 생성됩니다.
4. FileNotFoundException : 존재하지 않는 파일을 열려고 할 때 생성됩니다.
5. NumberFormatException : 문자열을 숫자로 변환하는 메서드에 의해 생성됩니다. 예를 들어, Integer.parseInt는 매개변수로 전달된 문자열에 숫자가 포함되지 않은 경우 이 유형의 예외를 생성합니다.

### throws 절
- 모든 java메소드는 throws 절을 사용하여 호출하는 메소드에 의해 생성된 예외를 처리할 수 있습니다.
- throws 절이 메서드정의의 헤더에 추가됩니다.

### 확인된 예외 및 런타임 예외
- 확인된 예외는 해당 예외 가 발생할 수 있는 모든 메서드의 throws 절 에 언급되어야 합니다. 그런 다음 이러한 예외는 예외가 발생한 메서드를 호출하는 메서드로 전파됩니다.
- 메서드 A가 MyException 유형의 예외를 발생시키도록 선언하는 경우 A 를 호출하는 모든 메서드는 이러한 예외를 발생시킨다고 자체적으로 선언하거나 예외를 포착해야 합니다. 따라서 다음 코드 조각은 잘못된 것입니다. 왜냐하면 메서드 B 가 MyException 유형의 예외를 발생시키도록 선언하지 않고 A 에서 생성할 수 있는 예외를 포착하지 않기 때문입니다.

```java
public static void A() throws MyException {
  ...
}

public static void B() {
  A();
}
// 확인되지 않은 예외는 RuntimeException 유형(하위 클래스)의 객체입니다 . 프로그램 실행 중에 JVM(Java Virtual Machine)에서 발생하는 예외를 나타냅니다.
```

- 산술 예외(예: 0으로 나누기)
- 참조 예외(예: null참조를 통해 객체에 액세스하려고 시도)
- 배열을 인덱싱할 때 예외(예: 인덱스가 너무 작거나 큰 배열 요소에 액세스하려고 시도하는 경우)

### 새로운 예외의 정의
- 새로운 예외는 Exception클래스나 그 하위 클래스 중 하나에서 시작하여 정의할 수 있습니다.

```java
public class MyException extends Exception {
  public MyException (String message) {
    super(message);
  }
}
```
- MyException 클래스는 시각화할 특정 메시지를 지정합니다. 예외 의 생성자는 예외가 발생할 때 인쇄되는 문자열을 매개변수로 사용합니다.
- Exception 대신 RuntimeException 의 하위 클래스로 예외 클래스를 정의하는 것도 가능합니다 . 이러한 방식으로 이러한 예외는 unchecked 유형이므로 명시적으로 처리할 필요가 없습니다 .

### throw 문
- 예외를 발생시키려면 throw문을 사용합니다
예외던지기

통사론: throw exceptionObject;
- 예외 객체 는 Exception 클래스 (또는 그 하위 클래스 중 하나)

의미론
- throw 문의 매개 변수로 나타나는 객체가 나타내는 유형의 예외를 발생시킵니다 .

### Example 
```java
import java.io.*;

public class UseMyException {
  public static void main(String[] args) throws MyException, IoException {
    int min = 10, max = 30;
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    System.out.println("" + min + 사이의 숫자를 입력하세요.
                       " and " + max + " included");
    int value = Integer.parseInt(br.readLine());
    if (value < min || value > max)
       throw new MyException("허용된 간격을 벗어난 값입니다.");
    System.out.println("값이 허용된 간격 내에 있습니다.");
  }
}
// 포함된 10~30 사이의 숫자를 입력하세요.
// 9
// 스레드 "main"의 예외 MyException: 값이 UseMyException.main(UseMyException.java:11)에서 허용된 간격을 벗어났습니다.
```

### 예외를 잡는 방법
- throw문은 throw문을 실행하는 메서드에서 시작하여 기본 메서드 부터 호출 메서드까지 진행되는 메서드 종료체인을 시작합니다.
- 예외가 발생하면 프로그램종료로 이어지는 일련의 예외가 중단딥니다.
- 예외를 포착하려면 try-catch-finally 구조를 사용할수 있습니다.

try-catch-finally 구조

통사론:
```java
try {
  try-block
}
catch(ExceptionClass1 e) {
  catch-block
}
catch(ExceptionClass2 e) {
  catch-block
}
...
finally {
  finally-block
}
```
- try-block : 다음 catch 절의 제어 하에 실행될 일련의 명령문
- catch-block : try-block 의 명령문이 해당 catch 절 에 지정된 유형의 예외를 생성하는경우 실행될 명령문 시퀀스
- finally-block : 항상 실행되는 일련의 명령문입니다( try-block이 예외 없이 실행되는 경우예외를 잡기 위해 catch-block이 실행되는 경우)

의미론:
- 코드 조각에서 발생할 수 있는 하나 이상의 예외를 포착합니다. 이러한 명령문 중 하나가 예외를 생성하는 경우 try-block 의 명령문 실행이 중단됩니다. 이런 일이 발생하면 catch 절은 작성된 순서대로 평가되고 생성된 예외가 지정된 클래스에 속하는 첫 번째 절에 해당하는 catch 블록이 실행됩니다. 마지막으로 finally 블록 의 명령문이 실행됩니다.
- try-block 의 어떤 문도 예외를 생성하지 않으면 실행이 끝나면 finally-block 의 문만 실행됩니다.

```java
try {
   System.out.println(Integer.parseInt(br.readLine());
}
catch(IOException e1) {
   System.out.println("An IO error occurred.");
}
catch(NumberFormatException e2) {
   System.out.println("The string read does not contain an integer.");
}
finally {
   System.out.println("Block executed.");
}
```
- 이 코드 조각은 입력 채널에서 읽은 문자열을 정수로 변환하고 정수를 인쇄하려고 시도합니다. IO 오류가 발생하거나 읽은 문자열에 일련의 숫자가 포함되어 있지 않으면 해당 오류 메시지가 비디오에 인쇄됩니다. 어떤 경우든 finally 절 에 해당하는 "Block 실행됨" 문자열에 대한 println 문이 실행됩니다.

### getMessage 메소드
- Exception 클래스와 모든 하위 클래스에는 예외와 관련된 문자열을 추출할 수 있는 getMessage() 메서드가 있습니다.

```java
try {
  ...
}
catch (NumberFormatException e) {
  System.out.println("Catched NumberFormatException");
  System.out.println(e.getMessage());
}
catch (IOException e) {
  System.out.println("Catched IOException");
  System.out.println(e.getMessage());
}
```

### 예외처리의 예

- data.txt 파일에 저장된 음수가 아닌 정수 값 시퀀스의 최대값을 인쇄하는 Java 프로그램을 작성하세요 .

```java
import java.io.*;

public class MaximumWithoutExceptions {
  public static void main (String args[]) throws IOException {
    BufferedReader br = new BufferedReader(new FileReader("data.txt"));
            // could generate FileNotFoundException (checked)
    int max = -1;

    String line = br.readLine();
            // could generate IOException (checked)
    while (line != null) {
      int n = Integer.parseInt(line);
          // could generate NumberFormatException (unchecked)
      if (n > max) max = n;
      line = br.readLine();
          // could generate IOException (checked)
    }
    System.out.println("Maximum = " + max);
  }
}
```

예외를 고려한 코드입니다.

```java
import java.io.*;

public class MaximumWithExceptions {
  public static void main (String args[]) {
    try {
      BufferedReader br = new BufferedReader(new FileReader("data.txt"));
                // could generate FileNotFoundException (checked)
      int max = -1;

      String line = br.readLine();
                // could generate IOException (checked)
      while (line != null) {
        int n = Integer.parseInt(line);
                // could generate NumberFormatException (unchecked)
        if (n > max) max = n;
        line = br.readLine();
                // could generate IOException (checked)
      }
      if (max == -1)
         throw new Exception("File empty or all numbers < 0");
      else
         System.out.println("Maximum = " + max);
      }
    catch (FileNotFoundException e) {
       System.out.println("The file does not exist.");
    }
    catch (IOException e) {
       System.out.println("The file cannot be read.");
    }
    catch (NumberFormatException e) {
       System.out.println("The file contains non numeric data.");
    }
    catch (Exception e) {
       System.out.println(e.getMessage());
    }
  }
}
```

파일에 정수 값으로 변환할 수 없는 영숫자 데이터가 포함되어 있으면 첫 번째 프로그램에서 다음 오류 메시지가 생성됩니다.

Exception in thread "main" java.lang.NumberFormatException: For input string: "pippo"
  at java.lang.NumberFormatException.forInputString(NumberFormatException.java:48)
  at java.lang.Integer.parseInt(Integer.java:468)
  at java.lang.Integer.parseInt(Integer.java:518)
  at MaximumWithoutExceptions.main(MaximumWithoutExceptions.java:12)

대신 두 번째 프로그램은 예외를 처리하고 다음을 인쇄합니다.

파일에 숫자가 아닌 데이터가 포함되어 있습니다.

### 예외전파
- 예외가 발생한 곳에서 에외가 포착되지 않고 처리되지않으면 예외가 발생한 메서드를 호출한 메서드로 제어가 전달됩니다.
- 예외가 포착되거나 컨트롤이 프로그램을 종료하고 오류메시지를 생성하는 기본메서드로 전달 될때까지 전파가 계속됩니다.

```java
import java.io.*;

public class ExceptionPropagation1 {

  public static void main(String[] args) throws Exception {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    System.out.println("Insert a number:");
    int c = Integer.parseInt(br.readLine());
    first(c);
  }

  private static void first(int a) throws Exception {
    second(a);
  }

  private static void second(int b) throws Exception {
    Exception propagate = new Exception("The value is too small.");
    if (b < 10)
      throw propagate;
    System.out.println("OK");
  }
}
```
프로그램이 10보다 작은 값을 읽으면 예외가 발생하고 다음 메시지가 인쇄됩니다.
Exception in thread "main" java.lang.Exception: The value is too small.
  at ExceptionPropagation1.second(ExceptionPropagation1.java:17)
  at ExceptionPropagation1.first(ExceptionPropagation1.java:13)
  at ExceptionPropagation1.main(ExceptionPropagation1.java:9)


### 예외전파 중단
- 예외를 생성하는 메서드에서 예외가 처리되지 않고 예외를 생성하는 메서드를 호출하는 메서드에서 처리됩니다. 그러면 예외가 더 이상 위쪽으로 전파되지 않습니다. 따라서 첫 번째 및 주요 메소드는 예외를 발생시키도록 throws 절 에서 선언할 필요가 없습니다.

```java
import java.io.*;

public class ExceptionPropagation2 {

  public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    System.out.println("Insert a number:");
    int c = Integer.parseInt(br.readLine());
    first(c);
  }

  private static void first(int a) {
    try {
      second(a);
    }
    catch (Exception e) {
      System.out.println("Exception handled in the first method.");
      System.out.println(e.getMessage());
    }
  }

  private static void second(int b) throws Exception {
    Exception propagate = new Exception("The value is too small.");
    if (b < 10)
      throw propagate;
    System.out.println("OK");
  }
}
```
실행결과
숫자 삽입:
5
첫번째 방법에서 예외가 처리되었습니다.
값이 너무 작습니다.

### 파일에서 읽을떄 예외 처리의 예
- 파일에서 정수 값을 읽고 이를 표준으로 인쇄하는 printIntegers 메소드를 작성합니다. 정수값을 포함하지 않는 파일 행(예: 앞파벳 문자 포함)의 경우 프로그램은 "***" 문자열을 인쇄 하고 파일에서 계속 읽어줘야 합니다.

```java
public static void printIntegers(String filename) {
  try {  // cattura exceptions di IO
    FileReader f = new FileReader(filename);
    BufferedReader in = new BufferedReader(f);
    String line = in.readLine();
    while (line != null) {
      try { // capture NumberFormaException
        int n = Integer.parseInt(line);
        System.out.println(n);
      }
      catch(NumberFormatException e) {
        System.out.println("***");
      }
      line = in.readLine();
   }
  }
  catch (IOException e) {
    System.out.println(e.getMessage());
  }
}
```
